// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Session {
  id            String    @id
  shop          String
  state         String
  isOnline      Boolean   @default(false)
  scope         String?
  expires       DateTime?
  accessToken   String
  userId        BigInt?
  firstName     String?
  lastName      String?
  email         String?
  accountOwner  Boolean   @default(false)
  locale        String?
  collaborator  Boolean?  @default(false)
  emailVerified Boolean?  @default(false)
  refreshToken        String?
  refreshTokenExpires DateTime?
}

/// Lions Creek Rewards â€” v1.1
/// SQLite note: lists/maps are stored as Json (backed by TEXT).

enum LedgerType {
  EARN
  REVERSAL
  REDEEM
  ADJUST
  EXPIRE
}

enum RedemptionStatus {
  ISSUED
  APPLIED
  CONSUMED
  VOID
  EXPIRED
  CANCELLED
}

/// Webhook processing outcomes (admin-visible logging)
enum WebhookOutcome {
  RECEIVED
  PROCESSED
  SKIPPED
  FAILED
}

model ShopSettings {
  shop                String   @id
  earnRate             Int      @default(1)
  redemptionMinOrder   Int      @default(0)
  /// Arrays and maps (SQLite): store as Json (TEXT-backed).
  excludedCustomerTags Json?
  includeProductTags   Json?
  excludeProductTags   Json?
  redemptionSteps      Json?
  redemptionValueMap   Json?
  updatedAt            DateTime @default(now())
}

model CustomerPointsBalance {
  id               String   @id @default(cuid())
  shop             String
  customerId       String
  balance          Int      @default(0)
  lifetimeEarned   Int      @default(0)
  lifetimeRedeemed Int      @default(0)
  lastActivityAt   DateTime @default(now())
  expiredAt        DateTime?

  @@unique([shop, customerId], name: "shop_customerId")
  @@index([shop, customerId])
}

model PointsLedger {
  id          String     @id @default(cuid())
  shop        String
  customerId  String
  type        LedgerType
  delta       Int
  source      String
  sourceId    String
  description String
  createdAt   DateTime   @default(now())

  @@index([shop, customerId, createdAt])

  /// Existing safety (event-level dedupe scoped to customer)
  @@unique([shop, customerId, type, source, sourceId], name: "ledger_dedupe")

  /// NEW: refund/cancel reversal dedupe regardless of customerId
  /// (matches your runtime check: shop+type+source+sourceId)
  @@unique([shop, type, source, sourceId], name: "ledger_refund_dedupe")
}

model OrderPointsSnapshot {
  id                     String   @id @default(cuid())
  shop                   String
  orderId                String
  orderName              String?
  customerId             String
  eligibleNetMerchandise Float    @default(0)
  pointsAwarded          Int      @default(0)
  pointsReversedToDate   Int      @default(0)
  paidAt                 DateTime
  cancelledAt            DateTime?
  currency               String   @default("CAD")

  // For audit/debug: discount codes present on the order at the time points were captured.
  discountCodesJson Json?

  @@unique([shop, orderId], name: "shop_orderId")
  @@index([shop, customerId])
}

model Redemption {
  id          String           @id @default(cuid())
  shop        String
  customerId  String
  // Points consumed to issue this redemption.
  points      Int
  value       Int
  code        String

  // GraphQL ID for the created CodeDiscountNode (used for deactivate/delete).
  discountNodeId String?

  // Client-provided idempotency key (prevents duplicate issuance).
  idemKey String?

  status      RedemptionStatus @default(ISSUED)
  createdAt   DateTime         @default(now())
  issuedAt    DateTime?
  appliedAt   DateTime?
  expiresAt   DateTime?

  // When this redemption was actually expired by a job.
  expiredAt DateTime?

  // When this redemption was consumed by an order.
  consumedAt      DateTime?
  consumedOrderId String?

  voidedAt    DateTime?
  cancelledAt DateTime?

  @@unique([shop, code], name: "shop_code")
  @@unique([shop, customerId, idemKey], name: "shop_customer_idemKey")
  @@index([shop, customerId, createdAt])
  @@index([shop, status, createdAt])
}

model WebhookEvent {
  id         String   @id @default(cuid())
  shop       String
  webhookId  String
  topic      String
  resourceId String
  receivedAt DateTime @default(now())

  /// NEW: outcome tracking fields
  outcome        WebhookOutcome @default(RECEIVED)
  outcomeCode    String?
  outcomeMessage String?
  processedAt    DateTime?

  @@unique([shop, webhookId], name: "shop_webhookId")
  @@index([shop, topic, receivedAt])
  @@index([shop, outcome, receivedAt])
}

model WebhookError {
  id        String   @id @default(cuid())
  shop      String
  topic     String
  webhookId String
  error     String
  createdAt DateTime @default(now())

  @@index([shop, createdAt])
}

model PrivacyEvent {
  id          String   @id @default(cuid())
  shop        String
  topic       String
  payloadJson String
  createdAt   DateTime @default(now())

  @@index([shop, createdAt])
}

model JobLock {
  key       String   @id
  createdAt DateTime @default(now())
}
